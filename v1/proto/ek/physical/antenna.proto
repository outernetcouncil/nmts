// Copyright (c) Outernet Council and Contributors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file contains messages used to model RF antennas and optical apertures.

syntax = "proto3";

package nmts.v1.ek.physical;

import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";

import "nmts/v1/proto/types/geophys/azimuth_elevation_mask.proto";
import "nmts/v1/proto/types/geophys/coordinates.proto";
import "nmts/v1/proto/types/physical/antenna_pattern.proto";
import "nmts/v1/proto/types/physical/emissions.proto";

option java_package = "org.outernetcouncil.nmts.v1.proto.ek.physical";
option go_package = "outernetcouncil.org/nmts/v1/proto/ek/physical";

// Models an RF antenna or optical aperture.
//
// There should be an RK_CONTAINS relationship between the Antenna and the
// nmts.ek.physical.Platform to which the antenna is attached, in the following
// direction: nmts.ek.physical.Platform --RK_CONTAINS--> Antenna.
// The Platform determines the base position and orientation axes of the
// Antenna, and a translational or rotational offset from the Platform's center
// can be defined in this message.
message Antenna {
  enum Type {
    TYPE_UNSPECIFIED = 0;
    RF = 1;
    OPTICAL = 2;
  }
  // Required.
  Type type = 1;

  /****************************************************************************/
  /* Physical Parameters                                                      */
  /****************************************************************************/
  // This field is deprecated. See the comments above supports_multiple_beams
  // for how an antenna with multiple beams is modeled.
  int32 max_num_beams = 2 [deprecated = true];

  // Indicates whether the antenna supports multiple, independently targetable
  // beams.
  //
  // When true, each carrier routed across this antenna is considered to be
  // transmitted or received in a separate beam. When false, all carriers are
  // considered to share a single beam.
  // The ability for multiple carriers to be routed across an antenna can be
  // modeled through graphs such as:
  //
  // EK_MODULATOR --> EK_SIGNAL_PROCESSING_CHAIN --> EK_TRANSMITTER ---|
  //                                                                   v
  //                                                                EK_ANTENNA
  //                                                                   ^
  // EK_MODULATOR --> EK_SIGNAL_PROCESSING_CHAIN --> EK_TRANSMITTER ---|
  //
  // (All edges are RK_SIGNAL_TRANSITS relationships.)
  //
  // In this example, each modulator may generate one or more carriers, so the
  // graph structure allows a model observer to determine that these carriers
  // are transmitted through the same antenna.
  bool supports_multiple_beams = 18;

  // The aggregate maximum transmit power across all beams formed by this
  // antenna, in watts.
  //
  // As an example of how this value is used for antennas that can form multiple
  // beams, suppose an antenna is capable of forming 8 beams and has a
  // maximum aggregate transmit power of 12 dBW (15.85 W). In a given time
  // interval, suppose the SDN Controller chooses to use all 8 beams. In this
  // case, each beam could have a transmit power of 3 dBW (1.98 W). In a
  // different time interval however, suppose the SDN Controller chooses to use
  // only 4 beams. In this case, each beam could have a maximum transmit power
  // of 6 dBW (3.96 W).
  //
  // The max_power_w in nmts.ek.physical.Transmitter.TransmitCarrier can further
  // constrain the maximum transmit power to model transmitters whose maximum
  // transmit power varies with frequency.
  //
  // Required.
  double max_transmit_power_w = 3;

  // Effective Isotropic Radiating Power (EIRP) limits.
  nmts.v1.types.physical.EirpLimits eirp_limits = 19;

  // Set to true if the antenna is mechanically-steerable. If an antenna is
  // only electronically-steerable, this will be false. Note that an 
  // antenna's electronic-steerability is implicitly determined based on the
  // type of antenna pattern in that any antennas with scan-angle-dependent
  // gain patterns (such as CustomGainPatternPerAngle) will be assumed to
  // be electronically-steerable.
  //
  // If enabled, the boresight direction of the antenna is oriented along the
  // link vector when evaluating the wireless propagation of the signal.
  // WARNING: If the gain pattern of an electronically steerable antenna varies
  // based on the scan angle, define a full 3D gain pattern at every scan
  // angle as an nmts.ek.physical.CustomAntennaPatternPerAngle and do *not* set
  // this field. The scan angle relative to the antenna's axes determines which
  // 3D gain pattern is referenced to look up the gain in the direction of the
  // link, so the antenna's axes should not be oriented along the link vector.
  // However, if the gain pattern does not vary based on scan angle, define the
  // 3D gain pattern as any pattern besides
  // nmts.ek.physical.CustomAntennaPatternPerAngle and *set* this field. When
  // the boresight direction of this antenna is oriented along the link vector,
  // the gain in the link direction will be the gain defined at phi = 0 and
  // theta = 0.
  //
  // If enabled, all beams that can be formed by this antenna are considered to
  // be steerable.
  //
  // Required.
  bool is_steerable = 4;

  message PointingFormat {
    oneof type {
      CartesianParameters cartesian = 1;
      StateVectorParameters state_vector = 2;
      ChebyshevCoefficients chebyshev_coefficients = 3;

      // Indicates that the antenna needs only the target `EK_ANTENNA`
      // identifier and is presumed to have an alternate mechanism to
      // determine relevant pointing information from this alone.
      google.protobuf.Empty target_antenna_id = 4;
    }

    message CartesianParameters {
      nmts.v1.types.geophys.CoordinateFrame reference_frame = 1;
    }

    message StateVectorParameters {
      nmts.v1.types.geophys.CoordinateFrame reference_frame = 1;
    }

    message ChebyshevCoefficients {
      nmts.v1.types.geophys.CoordinateFrame reference_frame = 1;

      // The minimum desired polynomial order, assumed to be required
      // for accurate pointing of this aperture.
      int32 min_order = 2;

      // The shortest desired time any set of coefficients should span.
      google.protobuf.Duration min_interval = 3;

      // The longest desirable time between updates of coefficients.
      //
      // Choosing a max_update_period shorter than min_interval can
      // allow for a system to provide overlap information according
      // to a desired strategy.  For example:
      //
      //     * max_update_period = 10 minutes
      //     * min_interval = 12 minutes
      //
      // would allow a system to allocate 2 minutes of overlap of
      // coefficients.
      google.protobuf.Duration max_update_period = 4;
    }
  }

  // A specification of the format that beam pointing information delivered to
  // the antenna should take.
  PointingFormat pointing_format = 17;

  // A fixed translational or rotational offset from the
  // nmts.ek.physical.Platform that has an RK_CONTAINS relationship with this
  // Antenna. If this field is not used, the antenna is considered to share the
  // position and orientation axes of the nmts.ek.physical.Platform.
  nmts.v1.types.geophys.PointAxes offset_from_platform_coordinates = 5;

  /****************************************************************************/
  /* Antenna Pattern                                                          */
  /****************************************************************************/
  // Models the antenna pattern that characterizes this antenna.
  nmts.v1.types.physical.AntennaPattern antenna_pattern = 6;

  /****************************************************************************/
  /* Noise Properties                                                         */
  /****************************************************************************/
  // The noise temperature of the antenna, in Kelvin
  // (https://en.wikipedia.org/wiki/Noise_temperature_(antenna)).
  // This field represents noise which comes from the antenna pointing at
  // Earth's albedo and other environmental effects which affect the signal
  // prior to reaching the signal processing chain. It is added to the noise
  // that is determined by the signal's wireless propagation analysis.
  double antenna_noise_temperature_k = 8;

  /****************************************************************************/
  /* Field of regard constraints                                              */
  /****************************************************************************/
  // The field of regard defines the total range that can be accessed when
  // considering the steering capabilities of the antenna.
  // In constrast, the field of view is the range within which the antenna can
  // transmit or receive a signal without any steering. The antenna pattern
  // describes the antenna's field of view.
  // For steerable antennas, this field specifies the total field of regard.
  // For non-steerable antennas, this field constrains the field of view defined
  // by the antenna pattern.
  nmts.v1.types.geophys.Projection field_of_regard = 9;

  // Obstructions that subtract from the field of regard.
  repeated nmts.v1.types.geophys.Projection obstructions = 10;

  // An Azimuth-Elevation Mask that describes how the horizon looks to an
  // antenna.
  nmts.v1.types.geophys.AzimuthElevationMask azimuth_elevation_mask = 11;

  /****************************************************************************/
  /* Physical constraints                                                     */
  /****************************************************************************/
  message LinkRangeConstraint {
    double minimum_range_m = 1;
    double maximum_range_m = 2;
  }
  LinkRangeConstraint link_range = 12;

  // AzimuthAngleRateConstraint is relative to the plane tangent to the
  // surface of the central body (Earth).  This is appropriate for ground
  // stations or other vehicles on the surface of the central body; but, for
  // aerospace platforms, it's usually better to use the
  // TotalAngularRateConstraint.
  message AzimuthAngleRateConstraint {
    double minimum_rate_deg_per_sec = 1;
    double maximum_rate_deg_per_sec = 2;
  }
  // To estimate the Duration required for a course-grained repointing
  // maneuver.
  AzimuthAngleRateConstraint azimuth_angle_rate = 13;

  message ElevationAngleRateConstraint {
    double minimum_rate_deg_per_sec = 1;
    double maximum_rate_deg_per_sec = 2;
  }
  // To estimate the Duration required for a course-grained repointing
  // maneuver.
  ElevationAngleRateConstraint elevation_angle_rate = 14;

  message TotalAngularRateConstraint {
    double minimum_rate_deg_per_sec = 1;
    double maximum_rate_deg_per_sec = 2;
  }
  // To estimate the Duration required for a course-grained repointing
  // maneuver.
  TotalAngularRateConstraint total_angular_rate = 15;

  // Additional Duration required for a steerable aperture to complete
  // link acquisition after course-grained (re)pointing has completed.
  // This might include, for example, time reserved for a fine-grained
  // search pattern.
  google.protobuf.Duration additional_acquisition_time = 20;

  // Link accessibility will be constrained when the angle between the sun's
  // center of mass and a receiving antenna's boresight is less than this
  // threshold (in degrees).
  // The sun is ~32 arcminutes in diameter when viewed from the Earth's surface,
  // and margin for that should be built into the configured value, if it is
  // significant to the user.
  double minimum_sun_angle_deg = 16;

  // TODO: Add beam hopping parameters.
}
